import numpy as np 
import matplotlib.pyplot as plt 
from numpy import random

def reward(w_prev, f, x, M=-100, L=100):
    return w_prev + (f(x)-L)/(M-L)

def pick(action):
    return random.uniform(action[0],action[1]) 

def length(action):
    return action[1]-action[0]

def midpoint(action):
    return action[0]+(action[1]-action[0])/2

def remove_interval(actions, l):
    #remove the lth interval (it is considered as stable and useless for further search)
    del actions[l] 
    a,b=actions[-1]
    #subdivide a remaining interval into two sub-intervals each corresponding to a new action
    #(the total number of actions is not changed)
    #subdividing the last interval... 
    del actions[-1]
    actions+=[(a,a+(b-a)/2),(a+(b-a)/2,b)]
    return actions

def find_peaks_and_valleys(dl):
    actionsk=[]
    peaks, valleys = [], []
    gamma=[dl[i+1]-dl[i] for i in range(len(dl)-1)]
    gprev=-gamma[0]
    a=dl[0]
    a2=dl[0]
    switch=0
    for i in range(len(gamma)): 
        g=np.sign(gamma[i])
        print(i,"  ",g,"  ",gamma[i])
        if gamma[i]==0.:
            print("g=0")
            continue 
        elif g*gprev<0: 
            print("switch1")
            #sign-switch 
            switch+=1
        if switch==2 or i==len(gamma)-1:
            print("switch2")
            if len(actionsk)>0:
                actionsk.append((a,dl[i]))
                a=dl[i]
            else:
                actionsk.append((a,dl[i]))
            switch-=1
        gprev=g
        
    return actionsk 

def initialize_actions(a, b, r):
    #(step 2)
    interval=(b-a)/r
    #actions:
    actions=list(zip(np.arange(a,b,interval),np.arange(a+interval,b+interval,interval)))
    return actions
    
def initialize_probs(f, r, actions):
    #(step 3) intialize w,z,d,p with the actions:
    
    #total reward for each action:
    w=[0 for i in range(r)]
    #number of times each action is chosen:
    z=[0 for i in range(r)]
    #initialize w and z by picking each action several times:
    for n in range(3):
        for i in range(r):
            x=pick(actions[i])
            w[i]+=reward(w[i],f,x)
            z[i]+=1
    #d=w/z:
    d=[i/j for i,j in zip(w,z)]
    #intialize each p_i as 1/r (probability of chosing action i)
    p=[1/r for i in range(r)]
    return w, z, d, p 
    
def calculate_probs(f, r, actions, w, z, d, p, lamb, delt):
    #(step 4) calculate p and d iteratively until condition is met
    while True:   
        wprev=w.copy()
        zprev=z.copy()
        dprev=d.copy()
        pprev=p.copy()
  
        #pick a random action according to distribution p:
        i_=random.choice(range(r),p=p)
        x=pick(actions[i_])
        #update w,z and d:
        w[i_]+=reward(w[i_],f,x)
        z[i_]+=1
        d[i_]=w[i_]/z[i_]
        #update p:
        dmax=max(d)
        imax=d.index(dmax)
        p=[(1.-lamb*dmax)*i for i in p]
        p[imax]+=lamb*dmax
        dmin=min(d)
        imin=d.index(dmin)
        if p[imin]<delt:
            break
            
    return wprev, zprev, dprev, pprev, max(dprev), dprev.index(max(dprev)), min(dprev), dprev.index(min(dprev))            

def find_maximum(f, a, b, r, eps, delt, lamb):
    """
    f,a,b   function on [a,b]
    r       number of sub-intervals divided
    eps     error band
    d       threshold of action probabilities (0 < D < 1/r)
    l       speed of convergence (0 < l < 1) 
    """
    midpointlist=[]
    #(step 2) initialize actions on the interval
    actions = initialize_actions(a, b, r)
    stop=False
    while True:
        print("*")
        if stop==True:
            break
        #(step 3) initialize d and p with these actions
        w, z, d, p = initialize_probs(f, r, actions)
        #(step 4) calculate d and p until condition is met
        w, z, d, p, dmax, imax, dmin, imin = calculate_probs(f, r, actions, w, z, d, p, lamb, delt)
        #(step 5) enhance the search in the lth interval
        l=imin
        al, bl = actions[l]
        deltl = delt*1.01 #such that 0<delt<deltl<1
        #(step 2) initialize new actions in the lth interval 
        actionsl = initialize_actions(al, bl, r)
        #(step 3) initialize dl and pl with these actions
        wl, zl, dl, pl = initialize_probs(f, r, actionsl)
        #(step 4) calculate pl and dl
        print("AAAAAAAA")
        wl, zl, dl, pl, dlmax, ilmax, dlmin, ilmin = calculate_probs(f, r, actionsl, wl, zl, dl, pl, lamb, deltl)
        print("BBBBBBBB")
        #calculate average reward and variance on the lth interval
        Md=np.mean(dl)
        D=max([abs(i-Md) for i in dl])
        if D<eps and dlmin<dmin:
            actions = remove_interval(actions, l)
            #go back to step 4 with updated actions etc.
            continue
        else: 
            #(step 6) lth interval is considered as unstable
            #checking the signs of the values to determine the peaks and valleys
            print("CCCCCCC")
            actionsk = find_peaks_and_valleys(dl)
            rk=len(actionsk)
            print(dl)
            print(rk)
            plt.plot(dl)
            plt.show()
            plt.close()
            #repeat steps 3 and 4 for calculating p and d
            wk, zk, dk, pk = initialize_probs(f, rk, actionsk)
            wk, zk, dk, pk, dkmax, ikmax, dkmin, ikmin = calculate_probs(f, rk, actionsk, wk, zk, dk, pk, lamb, delt)
            alm=actionsk[ikmax] #action corresponding to the largest d
            #replace the lth interval by the subinterval of alm:
            actions[l]=alm
            if length(alm)<eps:
                #(step 7) adding the midpoint of the lth interval to a list and remove this interval
                mp=midpoint(alm)
                midpointlist.append(mp)
                actions = remove_interval(actions, l)
                #if the number of remaining intervals is zero, then select the global optimum from the list and stop
                if len(actions)==0:
                    stop=True
                    continue
                else: 
                    continue     
            else: 
                #go back to step 4 with updated actions etc.
                continue

            
    return midpointlist
    

func=lambda x: np.cos(x/4)*(np.cos(3*x)+np.sin(6*x))
midpointlist=find_maximum(func,-10,10,10,0.05,0.01,0.1)
print(midpointlist)

xvals=np.arange(-10,10,0.1)
plt.figure(figsize=(15,3))
plt.plot(xvals,list(map(func,xvals)))
plt.plot(xvals, np.zeros(xvals.shape),color='black',linewidth=1)
plt.plot(midpointlist,[0 for i in midpointlist],marker="*",color='red')

plt.show()
